<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width,initial-scale=1.0">
<title>pebble_angle_continuous</title>
<style>
  html, body {
    margin: 0;
    background: #f6f5f2;
    height: 100%;
    display: grid;
    place-items: center;
  }
  .stage {
    width: min(84vw, 960px);
    aspect-ratio: 4/3;
  }
  svg {
    width: 100%;
    height: 100%;
    touch-action: none;
    display: block;
  }
  .outline {
    fill: none;
    stroke: #111;
    stroke-width: 28px;
    stroke-linejoin: round;
    stroke-linecap: round;
  }
  .dotted {
    fill: none;
    stroke: #fff;
    stroke-width: 10px;
    stroke-dasharray: 32px 28px;
  }
  .hud {
    position: fixed;
    right: 1rem;
    bottom: 1rem;
    background: rgba(0,0,0,.65);
    color: #fff;
    font-family: monospace;
    padding: .5rem .7rem;
    border-radius: 6px;
  }
</style>
</head>
<body>
<div class="stage">
  <svg id="pebbleSvg" viewBox="0 0 1200 900">
    <path class="outline" d="M100,450 260,240 630,210 980,360 920,700 540,740 220,640Z"/>
    <path class="dotted"  d="M100,450 260,240 630,210 980,360 920,700 540,740 220,640Z"/>
    <g id="innerGroup">
      <path class="outline" d="M420,470 520,340 700,370 750,520 600,590Z"/>
      <path class="dotted"  d="M420,470 520,340 700,370 750,520 600,590Z"/>
    </g>
  </svg>
</div>

<div class="hud"><span id="angleVal">0</span>°</div>

<script>
(function(){
  const svg = document.getElementById("pebbleSvg");
  const inner = document.getElementById("innerGroup");
  const angleVal = document.getElementById("angleVal");

  let dragging = false;
  let center = {x:0,y:0}, centerReady = false;
  let currentAngle = 0;
  let prevRawAngle = 0;

  function initCenter() {
    if (centerReady) return;
    const bb = inner.getBBox();
    center = {x: bb.x + bb.width/2, y: bb.y + bb.height/2};
    centerReady = true;
  }

  function clientToSvg(e) {
    const pt = svg.createSVGPoint();
    pt.x = e.clientX; pt.y = e.clientY;
    return pt.matrixTransform(svg.getScreenCTM().inverse());
  }

  function atanDeg(px,py){ return Math.atan2(py-center.y, px-center.x)*180/Math.PI; }

  function applyRotation() {
    inner.setAttribute("transform",`rotate(${currentAngle},${center.x},${center.y})`);
    angleVal.textContent = currentAngle.toFixed(1);
  }

  function onDown(e){
    initCenter();
    const p = clientToSvg(e);
    prevRawAngle = atanDeg(p.x,p.y);
    dragging = true;
    e.preventDefault();
  }

  function onMove(e){
    if(!dragging) return;
    const p = clientToSvg(e);
    const raw = atanDeg(p.x,p.y);
    let delta = raw - prevRawAngle;

    // ここで360度境界の飛びを補正
    if (delta > 180) delta -= 360;
    if (delta < -180) delta += 360;

    currentAngle += delta;
    prevRawAngle = raw;

    // ±90度制限
    if (currentAngle < -90) currentAngle = -90;
    if (currentAngle >  90) currentAngle =  90;

    applyRotation();
    e.preventDefault();
  }

  function onUp(){ dragging = false; }

  svg.addEventListener("pointerdown", onDown);
  svg.addEventListener("pointermove", onMove);
  svg.addEventListener("pointerup", onUp);
  svg.addEventListener("pointercancel", onUp);
  svg.addEventListener("pointerleave", onUp);

  initCenter(); applyRotation();
})();
</script>
</body>
</html>