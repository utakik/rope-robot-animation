<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width,initial-scale=1.0">
<title>pebble_outer_follow_links</title>
<style>
  html, body {
    margin: 0;
    background: #f6f5f2;
    height: 100%;
    display: grid;
    place-items: center;
    font-family: system-ui, -apple-system, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
  }

  .stage {
    width: min(84vw, 960px);
    aspect-ratio: 4 / 3;
  }

  svg {
    width: 100%;
    height: 100%;
    touch-action: none; /* iPadでスクロールしない */
    display: block;
  }

  /* 太い黒い線（輪郭と同じ太さ・キャップ） */
  .outlineStroke {
    fill: none;
    stroke: #111;
    stroke-width: 28px;
    stroke-linejoin: round;
    stroke-linecap: round;
  }

  /* 白い点線（血管っぽいやつと同じ） */
  .dottedStroke {
    fill: none;
    stroke: #fff;
    stroke-width: 10px;
    stroke-linecap: butt;
    stroke-dasharray: 32px 28px;
  }

  .hud {
    position: fixed;
    right: 1rem;
    bottom: 1rem;
    background: rgba(0,0,0,.65);
    color: #fff;
    font-family: monospace;
    padding: .5rem .7rem;
    border-radius: 6px;
    line-height: 1.4;
    font-size: 12px;
    min-width: 9rem;
    user-select: none;
    pointer-events: none;
  }
  .row { display: flex; justify-content: space-between; }
  .key { color:#9c9c9c; padding-right:.5rem; }
  .val { color:#b2ff9b; font-variant-numeric: tabular-nums; text-align:right; }
</style>
</head>
<body>
<div class="stage">
  <svg id="pebbleSvg" viewBox="0 0 1200 900" aria-label="pebble with tendons">
    <!-- 外側の七角形をグループ化：これも少し回る -->
    <g id="outerGroup">
      <path class="outlineStroke"
            id="outerOutlinePath"
            d="M100,450 260,240 630,210 980,360 920,700 540,740 220,640Z"/>
      <path class="dottedStroke"
            id="outerDottedPath"
            d="M100,450 260,240 630,210 980,360 920,700 540,740 220,640Z"/>
    </g>

    <!-- 内側の五角形（メインで回る） -->
    <g id="innerGroup">
      <path class="outlineStroke"
            id="innerOutlinePath"
            d="M420,470 520,340 700,370 750,520 600,590Z"/>
      <path class="dottedStroke"
            id="innerDottedPath"
            d="M420,470 520,340 700,370 750,520 600,590Z"/>
    </g>

    <!-- 結線（腱）: 5本。それぞれ黒と白を重ねる -->
    <g id="linksLayer">
      <!-- link0 -->
      <path class="outlineStroke" id="link0Black" d="M0,0 L0,0"/>
      <path class="dottedStroke"  id="link0White" d="M0,0 L0,0"/>
      <!-- link1 -->
      <path class="outlineStroke" id="link1Black" d="M0,0 L0,0"/>
      <path class="dottedStroke"  id="link1White" d="M0,0 L0,0"/>
      <!-- link2 -->
      <path class="outlineStroke" id="link2Black" d="M0,0 L0,0"/>
      <path class="dottedStroke"  id="link2White" d="M0,0 L0,0"/>
      <!-- link3 -->
      <path class="outlineStroke" id="link3Black" d="M0,0 L0,0"/>
      <path class="dottedStroke"  id="link3White" d="M0,0 L0,0"/>
      <!-- link4 -->
      <path class="outlineStroke" id="link4Black" d="M0,0 L0,0"/>
      <path class="dottedStroke"  id="link4White" d="M0,0 L0,0"/>
    </g>
  </svg>
</div>

<div class="hud">
  <div class="row"><div class="key">inner</div><div class="val" id="innerVal">0.0°</div></div>
  <div class="row"><div class="key">outer</div><div class="val" id="outerVal">0.0°</div></div>
  <div class="row"><div class="key">gain</div><div class="val" id="gainVal">1.00</div></div>
</div>

<script>
(function(){
  const svg          = document.getElementById("pebbleSvg");
  const innerGroup   = document.getElementById("innerGroup");
  const outerGroup   = document.getElementById("outerGroup");

  const innerValEl   = document.getElementById("innerVal");
  const outerValEl   = document.getElementById("outerVal");
  const gainValEl    = document.getElementById("gainVal");

  // link要素
  const linkBlackEls = [
    document.getElementById("link0Black"),
    document.getElementById("link1Black"),
    document.getElementById("link2Black"),
    document.getElementById("link3Black"),
    document.getElementById("link4Black"),
  ];
  const linkWhiteEls = [
    document.getElementById("link0White"),
    document.getElementById("link1White"),
    document.getElementById("link2White"),
    document.getElementById("link3White"),
    document.getElementById("link4White"),
  ];

  // 幾何データ: 五角形の元頂点 (inner)
  const innerVerts = [
    { x:420, y:470 },
    { x:520, y:340 },
    { x:700, y:370 },
    { x:750, y:520 },
    { x:600, y:590 },
  ];

  // 七角形の元頂点 (outer)
  const outerVerts = [
    { x:100, y:450 },
    { x:260, y:240 },
    { x:630, y:210 },
    { x:980, y:360 },
    { x:920, y:700 },
    { x:540, y:740 },
    { x:220, y:640 },
  ];

  // ねじれマッピング（B案）
  // inner[0] -> outer[0]
  // inner[1] -> outer[2]
  // inner[2] -> outer[4]
  // inner[3] -> outer[5]
  // inner[4] -> outer[1]
  const mapping = [0, 2, 4, 5, 1];

  // 状態
  let dragging = false;

  // 内側（五角形）の角度。±90で制限される主角
  let innerAngle = 0;

  // ポインタ角度の前フレーム値
  let prevPointerAngle = 0;

  // 回転中心（五角形の中心）。一度だけ決める
  let center = {x:0,y:0};
  let centerReady = false;

  // 角度差を安定化：179→-179を-2にする
  function angleDelta(nowDeg, prevDeg){
    let diff = nowDeg - prevDeg;
    if (diff > 180)  diff -= 360;
    if (diff < -180) diff += 360;
    return diff;
  }

  // 回転中心
  function initCenterIfNeeded() {
    if (centerReady) return;
    const bbox = innerGroup.getBBox();
    center.x = bbox.x + bbox.width / 2;
    center.y = bbox.y + bbox.height / 2;
    centerReady = true;
  }

  // 画面座標→SVGローカル
  function clientToSvgXY(evt) {
    const pt = svg.createSVGPoint();
    pt.x = evt.clientX;
    pt.y = evt.clientY;
    return pt.matrixTransform(svg.getScreenCTM().inverse());
  }

  // 中心→点 の角度[deg]
  function pointerAngleDeg(px, py) {
    const dx = px - center.x;
    const dy = py - center.y;
    return Math.atan2(dy, dx) * 180 / Math.PI;
  }

  // 任意の点ptを、ある角度degだけcenterまわりに回転して返す
  function rotatePoint(pt, deg){
    const rad = deg * Math.PI / 180;
    const cosA = Math.cos(rad), sinA = Math.sin(rad);
    const dx = pt.x - center.x;
    const dy = pt.y - center.y;
    return {
      x: center.x + dx * cosA - dy * sinA,
      y: center.y + dx * sinA + dy * cosA
    };
  }

  // outerAngleを計算する（外殻がわずかに追従する）
  function calcOuterAngle(inner){
    // 内側の角度の1/15だけ反応、さらに±5°でクリップ
    let out = inner * (1/15);
    if (out < -5) out = -5;
    if (out >  5) out =  5;
    return out;
  }

  // 描画更新：形の回転と結線の更新
  function applyVisual(gainForHud){
    // 回転角
    const outerAngle = calcOuterAngle(innerAngle);

    // 1. グループ回転（見た目用）
    innerGroup.setAttribute(
      "transform",
      `rotate(${innerAngle},${center.x},${center.y})`
    );
    outerGroup.setAttribute(
      "transform",
      `rotate(${outerAngle},${center.x},${center.y})`
    );

    // 2. 結線のdを更新
    //    innerの各頂点をinnerAngleで回した位置、
    //    outerの対応頂点をouterAngleで回した位置を結ぶ
    for (let i = 0; i < mapping.length; i++) {
      const innerIdx = i;
      const outerIdx = mapping[i];

      const pIn  = rotatePoint(innerVerts[innerIdx],  innerAngle);
      const pOut = rotatePoint(outerVerts[outerIdx], outerAngle);

      const dStr = `M ${pIn.x},${pIn.y} L ${pOut.x},${pOut.y}`;

      linkBlackEls[i].setAttribute("d", dStr);
      linkWhiteEls[i].setAttribute("d", dStr);
    }

    // 3. HUD更新
    const t = Math.min(Math.abs(innerAngle)/90, 1);
    const gainNow = 1 - t*t; // 抵抗ゲイン（中心で1 / 端で0）

    innerValEl.textContent = innerAngle.toFixed(1) + "°";
    outerValEl.textContent = outerAngle.toFixed(2) + "°";
    gainValEl.textContent  = (gainForHud !== undefined
                              ? gainForHud
                              : gainNow).toFixed(2);
  }

  function onPointerDown(e){
    initCenterIfNeeded();
    dragging = true;

    const p = clientToSvgXY(e);
    prevPointerAngle = pointerAngleDeg(p.x, p.y);

    e.preventDefault();
  }

  function onPointerMove(e){
    if (!dragging) return;

    const p = clientToSvgXY(e);
    const nowA = pointerAngleDeg(p.x, p.y);

    // 指の小さな変化量
    let d = angleDelta(nowA, prevPointerAngle);
    prevPointerAngle = nowA;

    // 現在の角度に応じて抵抗をかける（二次関数でしびれていく）
    const t = Math.min(Math.abs(innerAngle)/90, 1); // 0〜1
    const gain = 1 - t*t; // 0近くで固まる
    d = d * gain;

    // 内側の回転角を更新
    innerAngle += d;

    // 絶対限界
    if (innerAngle < -90) innerAngle = -90;
    if (innerAngle >  90) innerAngle =  90;

    applyVisual(gain);
    e.preventDefault();
  }

  function onPointerUp(){
    dragging = false;
  }

  // イベント登録
  svg.addEventListener("pointerdown",   onPointerDown);
  svg.addEventListener("pointermove",   onPointerMove);
  svg.addEventListener("pointerup",     onPointerUp);
  svg.addEventListener("pointercancel", onPointerUp);
  svg.addEventListener("pointerleave",  onPointerUp);

  // 初期表示
  initCenterIfNeeded();
  applyVisual();
})();
</script>
</body>
</html>