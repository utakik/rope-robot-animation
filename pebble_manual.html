<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width,initial-scale=1.0">
<title>pebble_outer_follow_resistance</title>
<style>
  html, body {
    margin: 0;
    background: #f6f5f2;
    height: 100%;
    display: grid;
    place-items: center;
    font-family: system-ui, -apple-system, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
  }

  .stage {
    width: min(84vw, 960px);
    aspect-ratio: 4 / 3;
  }

  svg {
    width: 100%;
    height: 100%;
    touch-action: none; /* iPadでスクロールしない */
    display: block;
  }

  .outline {
    fill: none;
    stroke: #111;
    stroke-width: 28px;
    stroke-linejoin: round;
    stroke-linecap: round;
  }

  .dotted {
    fill: none;
    stroke: #fff;
    stroke-width: 10px;
    stroke-linecap: butt;
    stroke-dasharray: 32px 28px;
  }

  .hud {
    position: fixed;
    right: 1rem;
    bottom: 1rem;
    background: rgba(0,0,0,.65);
    color: #fff;
    font-family: monospace;
    padding: .5rem .7rem;
    border-radius: 6px;
    line-height: 1.4;
    font-size: 12px;
    min-width: 8rem;
    user-select: none;
    pointer-events: none;
  }
  .row { display: flex; justify-content: space-between; }
  .key { color:#9c9c9c; padding-right:.5rem; }
  .val { color:#b2ff9b; font-variant-numeric: tabular-nums; text-align:right; }
</style>
</head>
<body>
<div class="stage">
  <svg id="pebbleSvg" viewBox="0 0 1200 900">
    <!-- 外側の七角形（少しだけ追従させる） -->
    <g id="outerGroup">
      <path class="outline"
            d="M100,450 260,240 630,210 980,360 920,700 540,740 220,640Z"/>
      <path class="dotted"
            d="M100,450 260,240 630,210 980,360 920,700 540,740 220,640Z"/>
    </g>

    <!-- 内側の五角形（メインで回す） -->
    <g id="innerGroup">
      <path class="outline"
            d="M420,470 520,340 700,370 750,520 600,590Z"/>
      <path class="dotted"
            d="M420,470 520,340 700,370 750,520 600,590Z"/>
    </g>
  </svg>
</div>

<div class="hud">
  <div class="row"><div class="key">inner</div><div class="val" id="innerVal">0.0°</div></div>
  <div class="row"><div class="key">outer</div><div class="val" id="outerVal">0.0°</div></div>
  <div class="row"><div class="key">gain</div><div class="val" id="gainVal">1.00</div></div>
</div>

<script>
(function(){
  const svg        = document.getElementById("pebbleSvg");
  const innerGroup = document.getElementById("innerGroup");
  const outerGroup = document.getElementById("outerGroup");

  const innerValEl = document.getElementById("innerVal");
  const outerValEl = document.getElementById("outerVal");
  const gainValEl  = document.getElementById("gainVal");

  // 状態
  let dragging = false;

  // 内側の角度（ユーザー操作の結果。見た目）
  let innerAngle = 0;

  // 前フレームのポインタ角度
  let prevPointerAngle = 0;

  // 回転中心
  let center = {x:0,y:0};
  let centerReady = false;

  // 角度の差分を安定化（179→-179を-2として扱う）
  function angleDelta(nowDeg, prevDeg){
    let diff = nowDeg - prevDeg;
    if (diff > 180)  diff -= 360;
    if (diff < -180) diff += 360;
    return diff;
  }

  // 回転中心を一度だけ測る（五角形のBBoxの中心）
  function initCenterIfNeeded() {
    if (centerReady) return;
    const bbox = innerGroup.getBBox();
    center.x = bbox.x + bbox.width / 2;
    center.y = bbox.y + bbox.height / 2;
    centerReady = true;
  }

  // 画面座標→SVGローカル座標
  function clientToSvgXY(evt) {
    const pt = svg.createSVGPoint();
    pt.x = evt.clientX;
    pt.y = evt.clientY;
    return pt.matrixTransform(svg.getScreenCTM().inverse());
  }

  // 中心から見た指の角度[deg]
  function pointerAngleDeg(px, py) {
    const dx = px - center.x;
    const dy = py - center.y;
    return Math.atan2(dy, dx) * 180 / Math.PI;
  }

  // 描画反映
  function applyRotation(gainForHud) {
    // 内側：そのまま innerAngle
    innerGroup.setAttribute(
      "transform",
      `rotate(${innerAngle},${center.x},${center.y})`
    );

    // 外側：内側の角度の1/15だけ追従。ただし ±5°に制限
    let outerAngle = innerAngle * (1/15);
    if (outerAngle < -5) outerAngle = -5;
    if (outerAngle >  5) outerAngle =  5;
    outerGroup.setAttribute(
      "transform",
      `rotate(${outerAngle},${center.x},${center.y})`
    );

    // HUD
    innerValEl.textContent = innerAngle.toFixed(1) + "°";
    outerValEl.textContent = outerAngle.toFixed(2) + "°";

    // gain（抵抗の強さの表示用）
    if (gainForHud !== undefined) {
      gainValEl.textContent = gainForHud.toFixed(2);
    } else {
      // 最初の表示
      const t0 = Math.min(Math.abs(innerAngle)/90, 1);
      const g0 = 1 - t0*t0;
      gainValEl.textContent = g0.toFixed(2);
    }
  }

  function onPointerDown(e){
    initCenterIfNeeded();
    dragging = true;

    const p = clientToSvgXY(e);
    prevPointerAngle = pointerAngleDeg(p.x, p.y);

    e.preventDefault();
  }

  function onPointerMove(e){
    if (!dragging) return;

    const p = clientToSvgXY(e);
    const nowA = pointerAngleDeg(p.x, p.y);

    // 指の角度の変化（1フレームぶんの小さい差）
    let d = angleDelta(nowA, prevPointerAngle);

    // 次フレームのために覚える
    prevPointerAngle = nowA;

    // いまの角度が限界±90のどれくらい近いかを0〜1で測る
    // 0 = 中央に近い（軽い）
    // 1 = 端に近い（重い）
    const t = Math.min(Math.abs(innerAngle) / 90, 1);

    // 抵抗ゲイン（二次関数）
    // 中央では1.0、端で0.0
    const gain = 1 - t * t;

    // このゲインをかけることで、端に近いほど動きが鈍くなる
    d = d * gain;

    // 回転角を更新
    innerAngle += d;

    // 絶対限界はまだ±90°で切る（物理的ストッパー）
    if (innerAngle < -90) innerAngle = -90;
    if (innerAngle >  90) innerAngle =  90;

    applyRotation(gain);

    e.preventDefault();
  }

  function onPointerUp(){
    dragging = false;
  }

  svg.addEventListener("pointerdown",  onPointerDown);
  svg.addEventListener("pointermove",  onPointerMove);
  svg.addEventListener("pointerup",    onPointerUp);
  svg.addEventListener("pointercancel",onPointerUp);
  svg.addEventListener("pointerleave", onPointerUp);

  // 初期表示
  initCenterIfNeeded();
  applyRotation();
})();
</script>
</body>
</html>