<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<title>pebble_manual (reset: 指の位置に合わせてリセット)</title>
<style>
  html, body { height: 100%; }
  body { margin: 0; background: #f6f5f2; display: grid; place-items: center; font-family: ui-sans-serif, system-ui, -apple-system, "Segoe UI", Roboto, Helvetica, Arial;}
  .stage { width: min(84vw, 960px); aspect-ratio: 4 / 3;}
  svg { width: 100%; height: 100%; display: block; touch-action: none;}
  .outline { fill: none; stroke: #111; stroke-width: 28px; stroke-linejoin: round; stroke-linecap: round;}
  .divider { fill: none; stroke: #111; stroke-width: 28px; stroke-linecap: round;}
  .dotted, .divider-dotted { fill: none; stroke: #fff; stroke-linecap: butt; stroke-width: 10px; stroke-dasharray: 32px 28px; animation: flowOneWay 2.8s linear infinite;}
  @keyframes flowOneWay {0% { stroke-dashoffset: 0px;} 100% { stroke-dashoffset: -60px; }}
  .inner-rot { transform-box: fill-box; transform-origin: center; cursor: grab;}
  .inner-rot.dragging { cursor: grabbing;}
  .hud { position: fixed; right: 0.75rem; bottom: 0.75rem; background: rgba(0,0,0,0.65); color: #fff; font-size: 12px; line-height: 1.4; font-family: ui-monospace, SFMono-Regular, Consolas, "Liberation Mono", monospace; border-radius: 8px; padding: 0.5rem 0.6rem; min-width: 8rem; pointer-events: none; user-select: none;}
  .hud .val { color: #b2ff9b; font-variant-numeric: tabular-nums;}
</style>
</head>
<body>
<div class="stage">
<svg viewBox="0 0 1200 900" xmlns="http://www.w3.org/2000/svg" aria-label="interactive pebble with clamped rotation and stretchy tendons">
<!-- 外側の七角形（骨格） -->
<g id="outerGroup">
  <path class="outline" id="outerOutline" d="M 100,450 260,240 630,210 980,360 920,700 540,740 220,640 Z" />
  <path class="dotted" id="outerDotted" d="M 100,450 260,240 630,210 980,360 920,700 540,740 220,640 Z" />
</g>
<!-- 内側の五角形（筋肉）。これを回す -->
<g class="inner-rot" id="rotTarget">
  <path class="outline" d="M 420,470 520,340 700,370 750,520 600,590 Z" />
  <path class="dotted" d="M 420,470 520,340 700,370 750,520 600,590 Z" />
</g>
<!-- 接続線：黒（太） -->
<path class="divider" id="link0-black" d="M 420,470 L 100,450" />
<path class="divider" id="link1-black" d="M 520,340 L 260,240" />
<path class="divider" id="link2-black" d="M 700,370 L 630,210" />
<path class="divider" id="link3-black" d="M 750,520 L 980,360" />
<path class="divider" id="link4-black" d="M 600,590 L 920,700" />
<!-- 接続線：白い点線（血管っぽい） -->
<path class="divider-dotted" id="link0-white" d="M 420,470 L 100,450" />
<path class="divider-dotted" id="link1-white" d="M 520,340 L 260,240" />
<path class="divider-dotted" id="link2-white" d="M 700,370 L 630,210" />
<path class="divider-dotted" id="link3-white" d="M 750,520 L 980,360" />
<path class="divider-dotted" id="link4-white" d="M 600,590 L 920,700" />
</svg>
</div>
<div class="hud">
  angle
  <div class="val" id="angleVal">0.0°</div>
</div>
<script>
(function() {
  // 基本データ
  const rotTarget = document.getElementById('rotTarget');
  const outerOutline = document.getElementById('outerOutline');
  const outerDotted = document.getElementById('outerDotted');
  const angleVal  = document.getElementById('angleVal');
  const innerVerts = [
    { x:420, y:470 },
    { x:520, y:340 },
    { x:700, y:370 },
    { x:750, y:520 },
    { x:600, y:590 },
  ];
  const outerVerts = [
    { x:100, y:450 },
    { x:260, y:240 },
    { x:630, y:210 },
    { x:980, y:360 },
    { x:920, y:700 },
    { x:540, y:740 },
    { x:220, y:640 },
  ];
  const linkBlackEls = [
    document.getElementById('link0-black'),
    document.getElementById('link1-black'),
    document.getElementById('link2-black'),
    document.getElementById('link3-black'),
    document.getElementById('link4-black'),
  ];
  const linkWhiteEls = [
    document.getElementById('link0-white'),
    document.getElementById('link1-white'),
    document.getElementById('link2-white'),
    document.getElementById('link3-white'),
    document.getElementById('link4-white'),
  ];
  let dragging = false;
  let lastAngleDeg = 0;
  let dragStartShapeAngle = 0;
  let dragStartPointerAngleDeg = 0;
  let center = { x: 0, y: 0 };
  let originalOuterPathStr = "";
  const MIN_ANGLE = -90;
  const MAX_ANGLE =  90;
  function clampAngle(aDeg) {
    if (aDeg < MIN_ANGLE) return MIN_ANGLE;
    if (aDeg > MAX_ANGLE) return MAX_ANGLE;
    return aDeg;
  }
  function updateCenter() {
    const box = rotTarget.getBBox();
    center.x = box.x + box.width / 2;
    center.y = box.y + box.height / 2;
  }
  function clientToSvgCoords(svgEl, clientX, clientY) {
    const pt = svgEl.createSVGPoint();
    pt.x = clientX;
    pt.y = clientY;
    const p2 = pt.matrixTransform(svgEl.getScreenCTM().inverse());
    return { x: p2.x, y: p2.y };
  }
  function angleDegFromCenter(px, py) {
    const dx = px - center.x;
    const dy = py - center.y;
    return Math.atan2(dy, dx) * 180 / Math.PI;
  }
  function rotatePoint(pt, deg) {
    const rad = deg * Math.PI / 180;
    const cosA = Math.cos(rad);
    const sinA = Math.sin(rad);
    const dx = pt.x - center.x;
    const dy = pt.y - center.y;
    return {
      x: center.x + dx * cosA - dy * sinA,
      y: center.y + dx * sinA + dy * cosA,
    };
  }
  // 結線の外側端点だけ微動
  function getDeformedLinkOuterVerts() {
    let deformed = [];
    for (let i = 0; i < 5; i++) {
      const pIn = rotatePoint(innerVerts[i], lastAngleDeg);
      const pOut = outerVerts[i];
      const ratio = 0.1; // 1/10だけ引き寄せ
      deformed.push({
        x: pOut.x + (pIn.x - pOut.x) * ratio,
        y: pOut.y + (pIn.y - pOut.y) * ratio,
      });
    }
    return deformed;
  }
  function makePolygonPath(verts) {
    return verts.map((pt, i) => (i === 0 ? `M ${pt.x},${pt.y}` : `L ${pt.x},${pt.y}`)).join(' ') + ' Z';
  }
  function getAngleDiff(a, b) {
    let diff = a - b;
    while (diff < -180) diff += 360;
    while (diff > 180) diff -= 360;
    return diff;
  }
  function applyRotation() {
    rotTarget.style.transform = `rotate(${lastAngleDeg}deg)`;
    outerOutline.setAttribute('d', originalOuterPathStr);
    outerDotted.setAttribute('d', originalOuterPathStr);
    const deformedOuterVerts = getDeformedLinkOuterVerts();
    for (let i = 0; i < innerVerts.length; i++) {
      const pIn  = rotatePoint(innerVerts[i], lastAngleDeg);
      const pOut = deformedOuterVerts[i];
      const dStr = `M ${pIn.x},${pIn.y} L ${pOut.x},${pOut.y}`;
      linkBlackEls[i].setAttribute('d', dStr);
      linkWhiteEls[i].setAttribute('d', dStr);
    }
    angleVal.textContent = lastAngleDeg.toFixed(1) + '°';
  }

  // ---- 指の位置に合わせてリセット ----
  function onPointerDown(e) {
    dragging = true;
    rotTarget.classList.add('dragging');
    const svgEl = rotTarget.ownerSVGElement;
    updateCenter();
    const p = clientToSvgCoords(svgEl, e.clientX, e.clientY);
    const pointerAngle = angleDegFromCenter(p.x, p.y);
    lastAngleDeg = clampAngle(pointerAngle); // 指位置にリセット
    dragStartPointerAngleDeg = pointerAngle;
    dragStartShapeAngle = lastAngleDeg;
    applyRotation();
    e.preventDefault();
  }
  function onPointerMove(e) {
    if (!dragging) return;
    const svgEl = rotTarget.ownerSVGElement;
    const p = clientToSvgCoords(svgEl, e.clientX, e.clientY);
    const pointerAngleDeg = angleDegFromCenter(p.x, p.y);
    let pointerDiff = getAngleDiff(pointerAngleDeg, dragStartPointerAngleDeg);
    let rawAngle = dragStartShapeAngle + pointerDiff;
    let clamped = clampAngle(rawAngle);
    // ジャンプ防止: 制限端に達したら基準点リセット
    if (clamped !== rawAngle) {
      dragStartShapeAngle = clamped;
      dragStartPointerAngleDeg = pointerAngleDeg;
      lastAngleDeg = clamped;
    } else {
      lastAngleDeg = clamped;
    }
    applyRotation();
    e.preventDefault();
  }
  function endDrag() {
    if (!dragging) return;
    dragging = false;
    rotTarget.classList.remove('dragging');
  }
  function getOriginalOuterPathStr() {
    return makePolygonPath(outerVerts);
  }
  document.addEventListener('pointerdown', onPointerDown);
  document.addEventListener('pointermove', onPointerMove);
  document.addEventListener('pointerup', endDrag);
  document.addEventListener('pointercancel', endDrag);
  document.addEventListener('pointerleave', endDrag);
  updateCenter();
  originalOuterPathStr = getOriginalOuterPathStr();
  applyRotation();
})();
</script>
</body>
</html>
