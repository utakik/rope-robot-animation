<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width,initial-scale=1.0">
<title>pebble_outer_follow_links_A</title>
<style>
  html, body {
    margin: 0;
    background: #f6f5f2;
    height: 100%;
    display: grid;
    place-items: center;
    font-family: system-ui, -apple-system, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
  }

  .stage {
    width: min(84vw, 960px);
    aspect-ratio: 4 / 3;
  }

  svg {
    width: 100%;
    height: 100%;
    touch-action: none; /* iPadでスクロールしない */
    display: block;
  }

  /* 太い黒い線（外郭と同じ表現） */
  .outlineStroke {
    fill: none;
    stroke: #111;
    stroke-width: 28px;
    stroke-linejoin: round;
    stroke-linecap: round;
  }

  /* 白い点線（外郭と同じ表現） */
  .dottedStroke {
    fill: none;
    stroke: #fff;
    stroke-width: 10px;
    stroke-linecap: butt;
    stroke-dasharray: 32px 28px;
  }

  .hud {
    position: fixed;
    right: 1rem;
    bottom: 1rem;
    background: rgba(0,0,0,.65);
    color: #fff;
    font-family: monospace;
    padding: .5rem .7rem;
    border-radius: 6px;
    line-height: 1.4;
    font-size: 12px;
    min-width: 9rem;
    user-select: none;
    pointer-events: none;
  }
  .row { display: flex; justify-content: space-between; }
  .key { color:#9c9c9c; padding-right:.5rem; }
  .val { color:#b2ff9b; font-variant-numeric: tabular-nums; text-align:right; }
</style>
</head>
<body>
<div class="stage">
  <svg id="pebbleSvg" viewBox="0 0 1200 900" aria-label="pebble with tendons">
    <!-- 外側の七角形グループ：外殻。少しだけ回る -->
    <g id="outerGroup">
      <path class="outlineStroke"
            id="outerOutlinePath"
            d="M100,450 260,240 630,210 980,360 920,700 540,740 220,640Z"/>
      <path class="dottedStroke"
            id="outerDottedPath"
            d="M100,450 260,240 630,210 980,360 920,700 540,740 220,640Z"/>
    </g>

    <!-- 内側の五角形グループ：内臓。大きく回る -->
    <g id="innerGroup">
      <path class="outlineStroke"
            id="innerOutlinePath"
            d="M420,470 520,340 700,370 750,520 600,590Z"/>
      <path class="dottedStroke"
            id="innerDottedPath"
            d="M420,470 520,340 700,370 750,520 600,590Z"/>
    </g>

    <!-- 結線（腱）: 5本分。黒と白を重ねて同じ見た目にする -->
    <g id="linksLayer">
      <!-- link0 -->
      <path class="outlineStroke" id="link0Black" d="M0,0 L0,0"/>
      <path class="dottedStroke"  id="link0White" d="M0,0 L0,0"/>
      <!-- link1 -->
      <path class="outlineStroke" id="link1Black" d="M0,0 L0,0"/>
      <path class="dottedStroke"  id="link1White" d="M0,0 L0,0"/>
      <!-- link2 -->
      <path class="outlineStroke" id="link2Black" d="M0,0 L0,0"/>
      <path class="dottedStroke"  id="link2White" d="M0,0 L0,0"/>
      <!-- link3 -->
      <path class="outlineStroke" id="link3Black" d="M0,0 L0,0"/>
      <path class="dottedStroke"  id="link3White" d="M0,0 L0,0"/>
      <!-- link4 -->
      <path class="outlineStroke" id="link4Black" d="M0,0 L0,0"/>
      <path class="dottedStroke"  id="link4White" d="M0,0 L0,0"/>
    </g>
  </svg>
</div>

<div class="hud">
  <div class="row"><div class="key">inner</div><div class="val" id="innerVal">0.0°</div></div>
  <div class="row"><div class="key">outer</div><div class="val" id="outerVal">0.0°</div></div>
  <div class="row"><div class="key">gain</div><div class="val" id="gainVal">1.00</div></div>
</div>

<script>
(function(){
  const svg          = document.getElementById("pebbleSvg");
  const innerGroup   = document.getElementById("innerGroup");
  const outerGroup   = document.getElementById("outerGroup");

  const innerValEl   = document.getElementById("innerVal");
  const outerValEl   = document.getElementById("outerVal");
  const gainValEl    = document.getElementById("gainVal");

  // 結線用の黒・白パスを配列で持つ
  const linkBlackEls = [
    document.getElementById("link0Black"),
    document.getElementById("link1Black"),
    document.getElementById("link2Black"),
    document.getElementById("link3Black"),
    document.getElementById("link4Black"),
  ];
  const linkWhiteEls = [
    document.getElementById("link0White"),
    document.getElementById("link1White"),
    document.getElementById("link2White"),
    document.getElementById("link3White"),
    document.getElementById("link4White"),
  ];

  // 幾何データ: 五角形の元頂点(内側)
  const innerVerts = [
    { x:420, y:470 },
    { x:520, y:340 },
    { x:700, y:370 },
    { x:750, y:520 },
    { x:600, y:590 },
  ];

  // 七角形の元頂点(外側)
  const outerVerts = [
    { x:100, y:450 },
    { x:260, y:240 },
    { x:630, y:210 },
    { x:980, y:360 },
    { x:920, y:700 },
    { x:540, y:740 },
    { x:220, y:640 },
  ];

  // A案の対応（まっすぐ系）
  // 五角形は5点、七角形は7点あるけど、外側の最初の5点を対応に使う
  //   inner[0] -> outer[0]
  //   inner[1] -> outer[1]
  //   inner[2] -> outer[2]
  //   inner[3] -> outer[3]
  //   inner[4] -> outer[4]
  const mapping = [4, 1, 2, 3, 5];

  // 状態
  let dragging = false;

  // 内側の回転角（ユーザーが動かす主角）
  let innerAngle = 0;

  // ポインタ角度（前フレーム）
  let prevPointerAngle = 0;

  // 回転の中心（五角形の中心）。一度計算したら固定
  let center = {x:0,y:0};
  let centerReady = false;

  // 角度差を安定化：±180°の壁を飛び越えたときに小さい差に丸める
  function angleDelta(nowDeg, prevDeg){
    let diff = nowDeg - prevDeg;
    if (diff > 180)  diff -= 360;
    if (diff < -180) diff += 360;
    return diff;
  }

  // 回転中心を一度だけ決める（内側グループのBBoxの中心）
  function initCenterIfNeeded() {
    if (centerReady) return;
    const bbox = innerGroup.getBBox();
    center.x = bbox.x + bbox.width / 2;
    center.y = bbox.y + bbox.height / 2;
    centerReady = true;
  }

  // 画面座標→SVG座標
  function clientToSvgXY(evt) {
    const pt = svg.createSVGPoint();
    pt.x = evt.clientX;
    pt.y = evt.clientY;
    return pt.matrixTransform(svg.getScreenCTM().inverse());
  }

  // 中心から見た指の角度[deg]
  function pointerAngleDeg(px, py) {
    const dx = px - center.x;
    const dy = py - center.y;
    return Math.atan2(dy, dx) * 180 / Math.PI;
  }

  // 任意の点ptを、centerまわりにdeg度回転させる
  function rotatePoint(pt, deg){
    const rad = deg * Math.PI / 180;
    const cosA = Math.cos(rad), sinA = Math.sin(rad);
    const dx = pt.x - center.x;
    const dy = pt.y - center.y;
    return {
      x: center.x + dx * cosA - dy * sinA,
      y: center.y + dx * sinA + dy * cosA
    };
  }

  // 外殻の角度を算出
  function calcOuterAngle(inner){
    // 内側の角度の1/15だけ反応、±5°で制限
    let out = inner * (1/15);
    if (out < -5) out = -5;
    if (out >  5) out =  5;
    return out;
  }

  // 画面の状態を全部更新する
  function applyVisual(gainForHud){
    const outerAngle = calcOuterAngle(innerAngle);

    // 内側の回転（大きく動く）
    innerGroup.setAttribute(
      "transform",
      `rotate(${innerAngle},${center.x},${center.y})`
    );

    // 外側の回転（少しだけつられる）
    outerGroup.setAttribute(
      "transform",
      `rotate(${outerAngle},${center.x},${center.y})`
    );

    // 結線を更新：
    // 五角形の各頂点を innerAngle で回転
    // 七角形の対応頂点を outerAngle で回転
    for (let i = 0; i < mapping.length; i++) {
      const innerIdx = i;
      const outerIdx = mapping[i];

      const pIn  = rotatePoint(innerVerts[innerIdx],  innerAngle);
      const pOut = rotatePoint(outerVerts[outerIdx], outerAngle);

      const dStr = `M ${pIn.x},${pIn.y} L ${pOut.x},${pOut.y}`;

      linkBlackEls[i].setAttribute("d", dStr);
      linkWhiteEls[i].setAttribute("d", dStr);
    }

    // HUD（内部角度、外側角度、ゲイン=柔らかさ）
    const t = Math.min(Math.abs(innerAngle)/90, 1); // 0〜1: 端に近いほど1
    const gainNow = 1 - t*t;                        // 二次関数で硬くなる
    innerValEl.textContent = innerAngle.toFixed(1) + "°";
    outerValEl.textContent = outerAngle.toFixed(2) + "°";
    gainValEl.textContent  = (gainForHud !== undefined
                              ? gainForHud
                              : gainNow).toFixed(2);
  }

  function onPointerDown(e){
    initCenterIfNeeded();
    dragging = true;

    const p = clientToSvgXY(e);
    prevPointerAngle = pointerAngleDeg(p.x, p.y);

    e.preventDefault();
  }

  function onPointerMove(e){
    if (!dragging) return;

    const p = clientToSvgXY(e);
    const nowA = pointerAngleDeg(p.x, p.y);

    // 指の回転の変化量（小さい差分）
    let d = angleDelta(nowA, prevPointerAngle);
    prevPointerAngle = nowA;

    // 角度が端に近いほど入力を鈍くする（二次関数ゲイン）
    const t = Math.min(Math.abs(innerAngle)/90, 1); // 0..1
    const gain = 1 - t*t;                           // 中央=1, 端=0
    d = d * gain;

    // 回転を更新
    innerAngle += d;

    // 絶対的な物理限界
    if (innerAngle < -90) innerAngle = -90;
    if (innerAngle >  90) innerAngle =  90;

    applyVisual(gain);
    e.preventDefault();
  }

  function onPointerUp(){
    dragging = false;
  }

  // イベント登録
  svg.addEventListener("pointerdown",   onPointerDown);
  svg.addEventListener("pointermove",   onPointerMove);
  svg.addEventListener("pointerup",     onPointerUp);
  svg.addEventListener("pointercancel", onPointerUp);
  svg.addEventListener("pointerleave",  onPointerUp);

  // 初期描画
  initCenterIfNeeded();
  applyVisual();
})();
</script>
</body>
</html>