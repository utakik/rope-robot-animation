<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<title>pebble_manual (ロック付き・減衰あり・安定版)</title>
<style>
  html, body { height: 100%; }

  body {
    margin: 0;
    background: #f6f5f2;
    display: grid;
    place-items: center;
    font-family: ui-sans-serif, system-ui, -apple-system, "Segoe UI", Roboto, Helvetica, Arial;
  }

  .stage {
    width: min(84vw, 960px);
    aspect-ratio: 4 / 3;
  }

  svg {
    width: 100%;
    height: 100%;
    display: block;
    touch-action: none; /* 指ドラッグでページがスクロールしないように */
  }

  /* ===== 黒い輪郭・腱ライン ===== */
  .outline {
    fill: none;
    stroke: #111;
    stroke-width: 28px;
    stroke-linejoin: round;
    stroke-linecap: round;
  }

  .divider {
    fill: none;
    stroke: #111;
    stroke-width: 28px;
    stroke-linecap: round;
  }

  /* ===== 白い流れる点線（血流） ===== */
  .dotted,
  .divider-dotted {
    fill: none;
    stroke: #fff;
    stroke-linecap: butt;
    stroke-width: 10px;
    stroke-dasharray: 32px 28px;
    animation: flowOneWay 2.8s linear infinite;
  }

  @keyframes flowOneWay {
    0%   { stroke-dashoffset: 0px; }
    100% { stroke-dashoffset: -60px; } /* 32 + 28 */
  }

  /* ===== 内側の五角形（回転する器官） ===== */
  .inner-rot {
    transform-box: fill-box;
    transform-origin: center;
    cursor: grab;
  }
  .inner-rot.dragging {
    cursor: grabbing;
  }

  /* ===== HUD（右下デバッグ） ===== */
  .hud {
    position: fixed;
    right: 0.75rem;
    bottom: 0.75rem;
    background: rgba(0,0,0,0.65);
    color: #fff;
    font-size: 12px;
    line-height: 1.4;
    font-family: ui-monospace, SFMono-Regular, Consolas, "Liberation Mono", monospace;
    border-radius: 8px;
    padding: 0.5rem 0.6rem;
    min-width: 10rem;
    pointer-events: none;
    user-select: none;
  }
  .hud .row  { display: flex; justify-content: space-between; }
  .hud .key  { color: #888; padding-right: .5rem; }
  .hud .val  { color: #b2ff9b; font-variant-numeric: tabular-nums; text-align: right; }
</style>
</head>
<body>
<div class="stage">
  <svg viewBox="0 0 1200 900"
       xmlns="http://www.w3.org/2000/svg"
       aria-label="interactive pebble with lock + decay">

    <!-- 外側の七角形（骨格） -->
    <g id="outerGroup">
      <path class="outline"
            id="outerOutline"
            d="M 100,450 260,240 630,210 980,360 920,700 540,740 220,640 Z" />
      <path class="dotted"
            id="outerDotted"
            d="M 100,450 260,240 630,210 980,360 920,700 540,740 220,640 Z" />
    </g>

    <!-- 内側の五角形（筋肉・器官） -->
    <g class="inner-rot" id="rotTarget">
      <path class="outline"
            d="M 420,470 520,340 700,370 750,520 600,590 Z" />
      <path class="dotted"
            d="M 420,470 520,340 700,370 750,520 600,590 Z" />
    </g>

    <!-- 接続線：黒い腱 -->
    <path class="divider"
          id="link0-black"
          d="M 420,470 L 100,450" />
    <path class="divider"
          id="link1-black"
          d="M 520,340 L 260,240" />
    <path class="divider"
          id="link2-black"
          d="M 700,370 L 630,210" />
    <path class="divider"
          id="link3-black"
          d="M 750,520 L 980,360" />
    <path class="divider"
          id="link4-black"
          d="M 600,590 L 920,700" />

    <!-- 接続線：白い点線（血管 / 張力の可視化） -->
    <path class="divider-dotted"
          id="link0-white"
          d="M 420,470 L 100,450" />
    <path class="divider-dotted"
          id="link1-white"
          d="M 520,340 L 260,240" />
    <path class="divider-dotted"
          id="link2-white"
          d="M 700,370 L 630,210" />
    <path class="divider-dotted"
          id="link3-white"
          d="M 750,520 L 980,360" />
    <path class="divider-dotted"
          id="link4-white"
          d="M 600,590 L 920,700" />
  </svg>
</div>

<div class="hud">
  <div class="row"><div class="key">angle</div><div class="val" id="angleVal">0.0°</div></div>
  <div class="row"><div class="key">ease</div><div class="val" id="easeVal">1.00</div></div>
  <div class="row"><div class="key">lock</div><div class="val" id="lockVal">none</div></div>
  <div class="row"><div class="key">ω</div><div class="val" id="omegaVal">0.00</div></div>
  <div class="row"><div class="key">accOK</div><div class="val" id="accVal">yes</div></div>
</div>

<script>
(function() {
  const rotTarget      = document.getElementById('rotTarget');
  const outerOutline   = document.getElementById('outerOutline');
  const outerDotted    = document.getElementById('outerDotted');

  const angleVal       = document.getElementById('angleVal');
  const easeVal        = document.getElementById('easeVal');
  const lockVal        = document.getElementById('lockVal');
  const omegaVal       = document.getElementById('omegaVal');
  const accVal         = document.getElementById('accVal');

  // 内側の五角形の元の頂点
  const innerVerts = [
    { x:420, y:470 },
    { x:520, y:340 },
    { x:700, y:370 },
    { x:750, y:520 },
    { x:600, y:590 },
  ];

  // 外側の七角形の頂点（0〜4はinnerVertsに対応、5,6は輪郭残り）
  const outerVerts = [
    { x:100, y:450 },
    { x:260, y:240 },
    { x:630, y:210 },
    { x:980, y:360 },
    { x:920, y:700 },
    { x:540, y:740 },
    { x:220, y:640 },
  ];

  // 腱ライン要素
  const linkBlackEls = [
    document.getElementById('link0-black'),
    document.getElementById('link1-black'),
    document.getElementById('link2-black'),
    document.getElementById('link3-black'),
    document.getElementById('link4-black'),
  ];
  const linkWhiteEls = [
    document.getElementById('link0-white'),
    document.getElementById('link1-white'),
    document.getElementById('link2-white'),
    document.getElementById('link3-white'),
    document.getElementById('link4-white'),
  ];

  // 環境判定（iPad/Androidなどはtrueにする）
  const ua = navigator.userAgent.toLowerCase();
  const isMobileLike = /iphone|ipad|android|mobile/.test(ua);

  // 制御パラメータ
  const MIN_ANGLE = -90;    // 最小回転角
  const MAX_ANGLE =  90;    // 最大回転角
  const DECAY_DURATION = 1200; // 減衰が0になるまでの時間(ms)
  const DRAG_START_THRESHOLD = 20; // 端から剥がすしきい値[deg]
  const RELEASE_THRESHOLD = 15;    // ロック解除に必要な戻し角[deg]
  const ACCEL_LIMIT = 0.002;       // モバイルでの不自然な急ブレーキしきい値 (deg/ms^2 的な雑指標)

  // 状態
  let dragging = false;           // いま押されてるか
  let dragActive = false;         // 入力が有効化済みか（端から十分離れたか）
  let lastAngleDeg = 0;           // 現在の確定角度（見た目の角度）
  let dragStartShapeAngle = 0;    // ドラッグ開始時点での角度
  let dragStartPointerAngleDeg = 0;
  let lastEase = 1;               // 減衰ゲイン(1→0)
  let dragStartTime = 0;          // pointerdownした時刻(ms)

  // ロック（端に当たって動かない状態）
  // lockedAtBoundary = false: 通常
  // true: 限界角に押しつけられてロック中
  // lockedSign = +1: MAX側でロック / -1: MIN側でロック
  let lockedAtBoundary = false;
  let lockedSign = 0;

  // 回転軸。最初の1回だけ決めて固定
  let center = { x:0, y:0 };
  let centerInitialized = false;

  // 角速度フィルタ用
  let prevPointerAngleDeg = null;
  let prevTimeMs = null;
  let prevOmega = 0;      // 前フレームの角速度[deg/ms]
  let accelOK = true;     // このフレームの入力を信用してよいか

  // 一度だけ回転中心を決める
  function initCenterIfNeeded() {
    if (centerInitialized) return;
    const box = rotTarget.getBBox();
    center.x = box.x + box.width / 2;
    center.y = box.y + box.height / 2;
    centerInitialized = true;
  }

  // 角度制限
  function clampAngle(aDeg) {
    if (aDeg < MIN_ANGLE) return MIN_ANGLE;
    if (aDeg > MAX_ANGLE) return MAX_ANGLE;
    return aDeg;
  }

  // 画面座標 -> SVGローカル座標
  function clientToSvgCoords(svgEl, clientX, clientY) {
    const pt = svgEl.createSVGPoint();
    pt.x = clientX;
    pt.y = clientY;
    const p2 = pt.matrixTransform(svgEl.getScreenCTM().inverse());
    return { x: p2.x, y: p2.y };
  }

  // 中心から見た指の角度[deg]
  function angleDegFromCenter(px, py) {
    const dx = px - center.x;
    const dy = py - center.y;
    return Math.atan2(dy, dx) * 180 / Math.PI;
  }

  // 点ptをcenterまわりにdeg度回す
  function rotatePoint(pt, deg) {
    const rad = deg * Math.PI / 180;
    const cosA = Math.cos(rad);
    const sinA = Math.sin(rad);
    const dx = pt.x - center.x;
    const dy = pt.y - center.y;
    return {
      x: center.x + dx * cosA - dy * sinA,
      y: center.y + dx * sinA + dy * cosA,
    };
  }

  // 角度差を -180〜180 に正規化
  function getAngleDiff(a, b) {
    let diff = a - b;
    while (diff < -180) diff += 360;
    while (diff > 180)  diff -= 360;
    return diff;
  }

  // 外郭ラインのdを"M ... L ... Z"形式で組む
  function makePolygonPath(verts) {
    let parts = [];
    for (let i = 0; i < verts.length; i++) {
      const cmd = (i === 0) ? 'M' : 'L';
      parts.push(`${cmd} ${verts[i].x},${verts[i].y}`);
    }
    parts.push('Z');
    return parts.join(' ');
  }

  // 引っ張られた腱の外端（外殻側）を計算
  // 角度が限界に近いほどratioが大きくなり、外殻が内側に引きずられる
  function getDeformedLinkOuterVerts() {
    const t = Math.min(Math.abs(lastAngleDeg) / 90, 1); // 0..1
    const ratio = 0.1 + (0.4 - 0.1) * t;               // 0.1〜0.4

    const pulled = [];
    for (let i = 0; i < 5; i++) {
      const pIn  = rotatePoint(innerVerts[i], lastAngleDeg);
      const pOut = outerVerts[i];
      pulled.push({
        x: pOut.x + (pIn.x - pOut.x) * ratio,
        y: pOut.y + (pIn.y - pOut.y) * ratio,
      });
    }
    return pulled;
  }

  // 画面更新
  function applyVisual() {
    // 内側五角形の回転
    rotTarget.style.transform = `rotate(${lastAngleDeg}deg)`;

    // 外郭（今は固定形状）
    const outerPathStr = makePolygonPath(outerVerts);
    outerOutline.setAttribute('d', outerPathStr);
    outerDotted.setAttribute('d',  outerPathStr);

    // 腱ラインの再計算
    const pulled = getDeformedLinkOuterVerts();
    for (let i = 0; i < innerVerts.length; i++) {
      const pIn  = rotatePoint(innerVerts[i], lastAngleDeg);
      const pOut = pulled[i];
      const dStr = `M ${pIn.x},${pIn.y} L ${pOut.x},${pOut.y}`;
      linkBlackEls[i].setAttribute('d', dStr);
      linkWhiteEls[i].setAttribute('d', dStr);
    }

    // HUD
    angleVal.textContent = lastAngleDeg.toFixed(1) + '°';
    easeVal.textContent  = lastEase.toFixed(2);
    lockVal.textContent  = lockedAtBoundary ? (lockedSign === 1 ? 'MAX' : 'MIN') : 'none';
    omegaVal.textContent = prevOmega.toFixed(3);
    accVal.textContent   = accelOK ? "yes" : "cut";
  }

  // 今の時間に対する減衰ゲイン（1→0に落ちていく）
  function computeEase(nowMs) {
    const dt = nowMs - dragStartTime;
    if (dt <= 0) return 1;
    if (dt >= DECAY_DURATION) return 0;
    return 1 - (dt / DECAY_DURATION);
  }

  // ----------------------------
  // pointer イベント
  // ----------------------------

  function onPointerDown(e) {
    dragging = true;
    dragActive = false;
    rotTarget.classList.add('dragging');

    initCenterIfNeeded();

    const p = clientToSvgCoords(rotTarget.ownerSVGElement, e.clientX, e.clientY);
    dragStartPointerAngleDeg = angleDegFromCenter(p.x, p.y);
    dragStartShapeAngle      = lastAngleDeg;

    dragStartTime = performance.now();
    lastEase = 1;

    // ロック状態は保持したままでいい（押し直してもロックは解除しない。これは選択次第）
    // ここでは保持することで、端に押し当てたまま指を離しても勝手にズレないようにしている。

    // 角速度フィルタ初期化
    prevPointerAngleDeg = dragStartPointerAngleDeg;
    prevTimeMs = dragStartTime;
    prevOmega = 0;
    accelOK = true;

    e.preventDefault();
  }

  function onPointerMove(e) {
    if (!dragging) {
      return;
    }

    const nowMs = performance.now();
    lastEase = computeEase(nowMs);

    // easeが0になったら、これ以上は動かない（疲労で固まったイメージ）
    if (lastEase <= 0.0001) {
      applyVisual();
      return;
    }

    const svgEl = rotTarget.ownerSVGElement;
    const p = clientToSvgCoords(svgEl, e.clientX, e.clientY);
    const pointerAngleDeg = angleDegFromCenter(p.x, p.y);

    // ---- 入力の安定化（モバイルの変なスパイクを切る） ----
    if (prevPointerAngleDeg != null && prevTimeMs != null) {
      const dt = nowMs - prevTimeMs;
      if (dt > 0) {
        const dAngle = getAngleDiff(pointerAngleDeg, prevPointerAngleDeg); // deg
        const omega = dAngle / dt;  // deg/ms
        const domega = Math.abs(omega - prevOmega) / dt; // 粗い加速度

        if (isMobileLike) {
          if (domega > ACCEL_LIMIT) {
            accelOK = false;
          } else {
            accelOK = true;
            prevOmega = omega;
          }
        } else {
          accelOK = true;
          prevOmega = omega;
        }

        prevPointerAngleDeg = pointerAngleDeg;
        prevTimeMs = nowMs;
      }
    } else {
      prevPointerAngleDeg = pointerAngleDeg;
      prevTimeMs = nowMs;
    }

    if (!accelOK) {
      // 入力スパイクは無視する
      applyVisual();
      return;
    }

    // ---- dragActive判定：端のロック状態からちゃんと引きはがされたか ----
    if (!dragActive) {
      const distFromCurrent = Math.abs(getAngleDiff(pointerAngleDeg, lastAngleDeg));
      if (distFromCurrent > DRAG_START_THRESHOLD) {
        dragStartPointerAngleDeg = pointerAngleDeg;
        dragStartShapeAngle      = lastAngleDeg;
        dragActive = true;
      } else {
        applyVisual();
        return;
      }
    }

    // ここから回転処理
    // pointerDiff = 現在の指角度 - ドラッグ開始時の指角度
    const pointerDiff = getAngleDiff(pointerAngleDeg, dragStartPointerAngleDeg);
    // 減衰をかけることで、長く押しているほど動きにくくなる
    const rawAngle = dragStartShapeAngle + pointerDiff * lastEase;

    // まだロックしてない状態
    if (!lockedAtBoundary) {
      const clamped = clampAngle(rawAngle);

      if (clamped !== rawAngle) {
        // 限界に当たった → ロック開始
        lastAngleDeg = clamped;
        lockedAtBoundary = true;
        lockedSign = (clamped === MAX_ANGLE) ? 1 : -1;

        // 重要：ここで dragStartShapeAngle / dragStartPointerAngleDeg を
        // "書き換えない"
        // つまり基準はそのまま保持する
        // → これがジャンプ防止の肝

      } else {
        // 普通に動けてる
        lastAngleDeg = clamped;
      }

    } else {
      // すでにロック中（MAXかMINで押しつけられてる）
      // ロック中は角度を変えない＝lastAngleDeg固定
      // ただし、十分戻してきたらロック解除して再キャリブレーション

      if (lockedSign === 1) {
        // MAX側(+90°近辺)でロックしてる
        // 指が MAX_ANGLE - RELEASE_THRESHOLD より小さい角度まで戻ったら解除
        if (rawAngle < MAX_ANGLE - RELEASE_THRESHOLD) {
          lockedAtBoundary = false;
          // 解除の瞬間の状態を新しい基準として使う
          dragStartShapeAngle      = lastAngleDeg;
          dragStartPointerAngleDeg = pointerAngleDeg;
        }
      } else if (lockedSign === -1) {
        // MIN側(-90°近辺)でロックしてる
        if (rawAngle > MIN_ANGLE + RELEASE_THRESHOLD) {
          lockedAtBoundary = false;
          dragStartShapeAngle      = lastAngleDeg;
          dragStartPointerAngleDeg = pointerAngleDeg;
        }
      }
      // ロック継続中は lastAngleDeg は変えない
    }

    applyVisual();
    e.preventDefault();
  }

  function endDrag() {
    if (!dragging) return;
    dragging   = false;
    dragActive = false;
    rotTarget.classList.remove('dragging');
    // ロック状態は保持する（意図的）
  }

  // イベントの登録
  document.addEventListener('pointerdown', onPointerDown);
  document.addEventListener('pointermove', onPointerMove);
  document.addEventListener('pointerup', endDrag);
  document.addEventListener('pointercancel', endDrag);
  document.addEventListener('pointerleave', endDrag);

  // 初回表示：回転中心を決めてから描画
  initCenterIfNeeded();
  applyVisual();
})();
</script>
</body>
</html>