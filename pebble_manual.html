<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width,initial-scale=1.0">
<title>pebble_live</title>
<style>
  html, body {
    margin: 0;
    background: #f6f5f2;
    height: 100%;
    display: grid;
    place-items: center;
    font-family: system-ui, -apple-system, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
  }

  .stage {
    width: min(84vw, 960px);
    aspect-ratio: 4 / 3;
  }

  svg {
    width: 100%;
    height: 100%;
    touch-action: none; /* iPadでスクロールしない */
    display: block;
  }

  /* 太い黒い線（本体） */
  .outlineStroke {
    fill: none;
    stroke: #111;
    stroke-width: 28px;
    stroke-linejoin: round;
    stroke-linecap: round;
  }

  /* 白い点線（血流）。ここにアニメーションを与える */
  .dottedStroke {
    fill: none;
    stroke: #fff;
    stroke-width: 10px;
    stroke-linecap: butt;
    stroke-dasharray: 32px 28px;
    animation: flowOneWay 2.8s linear infinite;
  }

  /* 血流アニメーション:
     dashoffsetをマイナス方向に回し続けることで
     白い四角が一定方向へ流れていくように見える */
  @keyframes flowOneWay {
    0%   { stroke-dashoffset: 0px;   }
    100% { stroke-dashoffset: -60px; } /* 32+28=60 */
  }

  .hud {
    position: fixed;
    right: 1rem;
    bottom: 1rem;
    background: rgba(0,0,0,.65);
    color: #fff;
    font-family: monospace;
    padding: .5rem .7rem;
    border-radius: 6px;
    line-height: 1.4;
    font-size: 12px;
    min-width: 9rem;
    user-select: none;
    pointer-events: none;
  }
  .row { display: flex; justify-content: space-between; }
  .key { color:#9c9c9c; padding-right:.5rem; }
  .val { color:#b2ff9b; font-variant-numeric: tabular-nums; text-align:right; }
</style>
</head>
<body>
<div class="stage">
  <svg id="pebbleSvg" viewBox="0 0 1200 900" aria-label="pebble with animated tendons">
    <!-- 外側の七角形グループ：外殻。少しだけ回る -->
    <g id="outerGroup">
      <path class="outlineStroke"
            id="outerOutlinePath"
            d="M100,450 260,240 630,210 980,360 920,700 540,740 220,640Z"/>
      <path class="dottedStroke"
            id="outerDottedPath"
            d="M100,450 260,240 630,210 980,360 920,700 540,740 220,640Z"/>
    </g>

    <!-- 内側の五角形グループ：内臓。大きく回る -->
    <g id="innerGroup">
      <path class="outlineStroke"
            id="innerOutlinePath"
            d="M420,470 520,340 700,370 750,520 600,590Z"/>
      <path class="dottedStroke"
            id="innerDottedPath"
            d="M420,470 520,340 700,370 750,520 600,590Z"/>
    </g>

    <!-- 結線（腱）: 黒と白の2枚重ねで5本 -->
    <g id="linksLayer">
      <path class="outlineStroke" id="link0Black" d="M0,0 L0,0"/>
      <path class="dottedStroke"  id="link0White" d="M0,0 L0,0"/>

      <path class="outlineStroke" id="link1Black" d="M0,0 L0,0"/>
      <path class="dottedStroke"  id="link1White" d="M0,0 L0,0"/>

      <path class="outlineStroke" id="link2Black" d="M0,0 L0,0"/>
      <path class="dottedStroke"  id="link2White" d="M0,0 L0,0"/>

      <path class="outlineStroke" id="link3Black" d="M0,0 L0,0"/>
      <path class="dottedStroke"  id="link3White" d="M0,0 L0,0"/>

      <path class="outlineStroke" id="link4Black" d="M0,0 L0,0"/>
      <path class="dottedStroke"  id="link4White" d="M0,0 L0,0"/>
    </g>
  </svg>
</div>

<div class="hud">
  <div class="row"><div class="key">inner</div><div class="val" id="innerVal">0.0°</div></div>
  <div class="row"><div class="key">outer</div><div class="val" id="outerVal">0.0°</div></div>
  <div class="row"><div class="key">gain</div><div class="val" id="gainVal">1.00</div></div>
</div>

<script>
(function(){
  const svg          = document.getElementById("pebbleSvg");
  const innerGroup   = document.getElementById("innerGroup");
  const outerGroup   = document.getElementById("outerGroup");

  const innerValEl   = document.getElementById("innerVal");
  const outerValEl   = document.getElementById("outerVal");
  const gainValEl    = document.getElementById("gainVal");

  // 結線用のパス要素
  const linkBlackEls = [
    document.getElementById("link0Black"),
    document.getElementById("link1Black"),
    document.getElementById("link2Black"),
    document.getElementById("link3Black"),
    document.getElementById("link4Black"),
  ];
  const linkWhiteEls = [
    document.getElementById("link0White"),
    document.getElementById("link1White"),
    document.getElementById("link2White"),
    document.getElementById("link3White"),
    document.getElementById("link4White"),
  ];

  // 五角形（内側）の元頂点
  const innerVerts = [
    { x:420, y:470 }, // 0
    { x:520, y:340 }, // 1
    { x:700, y:370 }, // 2
    { x:750, y:520 }, // 3
    { x:600, y:590 }, // 4
  ];

  // 七角形（外側）の元頂点
  const outerVerts = [
    { x:100, y:450 }, // 0
    { x:260, y:240 }, // 1
    { x:630, y:210 }, // 2
    { x:980, y:360 }, // 3
    { x:920, y:700 }, // 4
    { x:540, y:740 }, // 5
    { x:220, y:640 }, // 6
  ];

  // あなたが調整した対応を反映（例：左下の点を右下側に引っ張る等）
  // inner[i] -> outer[mapping[i]]
  // 必要に応じてここだけあとで自由に並べ替えればOK
  const mapping = [6, 1, 3, 4, 5];
  //  meaning:
  //  inner[0]→outer[4]
  //  inner[1]→outer[1]
  //  inner[2]→outer[2]
  //  inner[3]→outer[3]
  //  inner[4]→outer[5]

  // 状態
  let dragging = false;
  let innerAngle = 0;           // ユーザーが回す角度（主体）
  let prevPointerAngle = 0;     // 前フレームの指角度
  let center = {x:0,y:0};       // 回転の中心（五角形の中心）
  let centerReady = false;

  // 角度差を安定化：±180°を跨いだ時の急ジャンプを抑える
  function angleDelta(nowDeg, prevDeg){
    let diff = nowDeg - prevDeg;
    if (diff > 180)  diff -= 360;
    if (diff < -180) diff += 360;
    return diff;
  }

  // 回転中心を一度だけ計算
  function initCenterIfNeeded() {
    if (centerReady) return;
    const bbox = innerGroup.getBBox();
    center.x = bbox.x + bbox.width / 2;
    center.y = bbox.y + bbox.height / 2;
    centerReady = true;
  }

  // 画面座標→SVGローカル座標
  function clientToSvgXY(evt) {
    const pt = svg.createSVGPoint();
    pt.x = evt.clientX;
    pt.y = evt.clientY;
    return pt.matrixTransform(svg.getScreenCTM().inverse());
  }

  // 中心から見た指の角度[deg]
  function pointerAngleDeg(px, py) {
    const dx = px - center.x;
    const dy = py - center.y;
    return Math.atan2(dy, dx) * 180 / Math.PI;
  }

  // 任意の点ptを center まわりに deg 度回転
  function rotatePoint(pt, deg){
    const rad = deg * Math.PI / 180;
    const cosA = Math.cos(rad), sinA = Math.sin(rad);
    const dx = pt.x - center.x;
    const dy = pt.y - center.y;
    return {
      x: center.x + dx * cosA - dy * sinA,
      y: center.y + dx * sinA + dy * cosA
    };
  }

  // 外殻の角度：内側につられて少しだけ回る
  function calcOuterAngle(inner){
    let out = inner * (1/15); // 内側の1/15くらい
    if (out < -5) out = -5;
    if (out >  5) out =  5;
    return out;
  }

  // 今の角度に応じて、指の入力をどれだけ通すか
  // 端(±90°)に近いほど動きが鈍くなる：二次関数ゲイン
  function currentGain(angle){
    const t = Math.min(Math.abs(angle)/90, 1); // 0..1
    return 1 - t*t; // 中央=1, 端=0
  }

  // 描画更新
  function applyVisual(gainForHud){
    const outerAngle = calcOuterAngle(innerAngle);

    // 内側の回転
    innerGroup.setAttribute(
      "transform",
      `rotate(${innerAngle},${center.x},${center.y})`
    );

    // 外側の回転
    outerGroup.setAttribute(
      "transform",
      `rotate(${outerAngle},${center.x},${center.y})`
    );

    // 結線更新
    for (let i = 0; i < mapping.length; i++) {
      const innerIdx = i;
      const outerIdx = mapping[i];

      const pIn  = rotatePoint(innerVerts[innerIdx],  innerAngle);
      const pOut = rotatePoint(outerVerts[outerIdx], outerAngle);

      const dStr = `M ${pIn.x},${pIn.y} L ${pOut.x},${pOut.y}`;

      linkBlackEls[i].setAttribute("d", dStr);
      linkWhiteEls[i].setAttribute("d", dStr);
    }

    // HUD更新
    const gNow = gainForHud !== undefined ? gainForHud : currentGain(innerAngle);
    innerValEl.textContent = innerAngle.toFixed(1) + "°";
    outerValEl.textContent = outerAngle.toFixed(2) + "°";
    gainValEl.textContent  = gNow.toFixed(2);
  }

  function onPointerDown(e){
    initCenterIfNeeded();
    dragging = true;

    const p = clientToSvgXY(e);
    prevPointerAngle = pointerAngleDeg(p.x, p.y);

    e.preventDefault(); // iPadの画面暴走止め
  }

  function onPointerMove(e){
    if (!dragging) return;

    const p = clientToSvgXY(e);
    const nowA = pointerAngleDeg(p.x, p.y);

    // 指の小さな変化量（ジャンプ補正済み）
    let d = angleDelta(nowA, prevPointerAngle);
    prevPointerAngle = nowA;

    // 角度の端に近づくと重くなるゲイン
    const gain = currentGain(innerAngle);
    d = d * gain;

    // 回転角を更新
    innerAngle += d;

    // 絶対ストッパー（物理的リミット）
    if (innerAngle < -90) innerAngle = -90;
    if (innerAngle >  90) innerAngle =  90;

    applyVisual(gain);
    e.preventDefault();
  }

  function onPointerUp(){
    dragging = false;
  }

  // イベント登録
  svg.addEventListener("pointerdown",   onPointerDown);
  svg.addEventListener("pointermove",   onPointerMove);
  svg.addEventListener("pointerup",     onPointerUp);
  svg.addEventListener("pointercancel", onPointerUp);
  svg.addEventListener("pointerleave",  onPointerUp);

  // 初期描画
  initCenterIfNeeded();
  applyVisual();
})();
</script>
</body>
</html>